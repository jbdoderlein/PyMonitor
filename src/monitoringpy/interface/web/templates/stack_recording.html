{% extends "base.html" %}

{% block content %}
<div class="container-fluid stack-trace-container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-3">
                <div class="card-header">
                    <h4 id="function-name" class="mb-0">Loading function...</h4>
                    <p id="function-info" class="text-muted mb-0">Module: <span id="module-path"></span>, Line: <span id="line-number"></span>, Time: <span id="function-time"></span></p>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <!-- Code Column -->
        <div class="col-6">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>Source Code</h5>
                </div>
                <div class="card-body p-0">
                    <pre><code id="code-container" class="language-python" style="height: 70vh; overflow: auto;"></code></pre>
                </div>
            </div>
        </div>

        <!-- Stack Trace Column -->
        <div class="col-6">
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center">
                        <h5 class="mb-0">Stack Trace Timeline</h5>
                        <span class="ms-3 text-muted" id="global-counter"></span>
                    </div>
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-sm btn-outline-primary" id="prev-stack">
                            <i class="bi bi-chevron-left"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="play-stack">
                            <i class="bi bi-play-fill"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="next-stack">
                            <i class="bi bi-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="timeline-container" style="height: 120px; overflow-x: auto;"></div>
                </div>
            </div>

            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>Variables at Line <span id="current-line"></span></h5>
                    <div class="d-flex align-items-center">
                        <!-- Snapshot navigation will be inserted here -->
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-sm btn-outline-primary active" id="locals-tab">Local Variables</button>
                            <button type="button" class="btn btn-sm btn-outline-primary" id="globals-tab">Global Variables</button>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="locals-container" style="height: calc(70vh - 250px); overflow: auto;">
                        <div class="text-center py-5" id="locals-loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-2">Loading variables...</p>
                        </div>
                        <div id="locals-content"></div>
                    </div>
                    <div id="globals-container" style="height: calc(70vh - 250px); overflow: auto; display: none;">
                        <div class="text-center py-5" id="globals-loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-2">Loading variables...</p>
                        </div>
                        <div id="globals-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Get function ID from URL
        const urlParts = window.location.pathname.split('/');
        const functionId = urlParts[urlParts.length - 1];
        
        // Load stack trace data
        loadStackTrace(functionId);
        
        // Setup tab switching for locals/globals
        document.getElementById('locals-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('globals-tab').classList.remove('active');
            document.getElementById('locals-container').style.display = 'block';
            document.getElementById('globals-container').style.display = 'none';
        });
        
        document.getElementById('globals-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('locals-tab').classList.remove('active');
            document.getElementById('globals-container').style.display = 'block';
            document.getElementById('locals-container').style.display = 'none';
        });
    });
    
    let currentStackData = null;
    let selectedSnapshotIndex = 0;
    let isPlaying = false;
    let playInterval = null;
    let firstLineOffset = 1; // Store the line offset globally
    
    async function loadStackTrace(functionId) {
        try {
            const response = await fetch(getApiUrl(`/api/stack-recording/${functionId}`));
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            currentStackData = data;
            
            // Display function metadata
            document.getElementById('function-name').textContent = data.function.name || data.function.function;
            
            // Extract and display module path instead of full file path
            const file = data.function.file || '';
            const modulePath = file.split('/').pop().replace('.py', '');
            document.getElementById('module-path').textContent = modulePath;
            document.getElementById('line-number').textContent = data.function.line;
            
            // Format and display function time if available
            const functionTime = data.function.time || data.function.start_time;
            if (functionTime) {
                const date = new Date(functionTime);
                document.getElementById('function-time').textContent = date.toLocaleString();
            } else {
                document.getElementById('function-time').textContent = 'N/A';
            }
            
            // Adapt to new API format - frames are the snapshots
            const snapshots = data.frames || [];

            // Display source code
            if (data.function.code) {
                // Store first_line_no globally for use with line highlighting
                firstLineOffset = 1; // Default value
                if (typeof data.function.code === 'object') {
                    firstLineOffset = parseInt(data.function.code.first_line_no) || 1;
                }
                displayCode(data.function.code, firstLineOffset);
            } else {
                document.getElementById('code-container').textContent = 'Source code not available';
            }
            
            // Create timeline
            createTimeline(snapshots);
            
            // Setup playback controls
            setupPlaybackControls();
            
            // Display initial snapshot
            if (snapshots && snapshots.length > 0) {
                displaySnapshot(0);
                updateGlobalCounter(0);
            }
        } catch (error) {
            console.error('Error loading stack recording:', error);
            document.getElementById('function-name').textContent = 'Error loading stack recording';
            document.getElementById('function-info').textContent = error.message;
        }
    }
    
    function displayCode(code, firstLineNo) {
        const codeContainer = document.getElementById('code-container');
        
        // Handle code that could be an object with content property or a direct string
        let codeContent = '';
        
        if (typeof code === 'object') {
            if (code.content) {
                codeContent = code.content;
            } else {
                codeContainer.textContent = 'Source code content not found';
                return;
            }
        } else if (typeof code === 'string') {
            codeContent = code;
        } else {
            codeContainer.textContent = 'Source code format not recognized';
            return;
        }
        
        // First, set the content for pre-highlighting
        codeContainer.textContent = codeContent;
        
        // Apply syntax highlighting
        hljs.highlightElement(codeContainer);
        
        // Get the highlighted HTML content
        const highlightedHtml = codeContainer.innerHTML;
        
        // Split the highlighted HTML by line breaks
        const highlightedLines = highlightedHtml.split('\n');
        
        // Add line numbers and make lines clickable while preserving highlighting
        const codeWithLineNumbers = highlightedLines.map((line, index) => {
            // Line number is offset by firstLineNo
            const lineNumber = index + firstLineNo;
            return `<div class="code-line" data-line="${lineNumber}" id="code-line-${lineNumber}"><span class="line-number">${lineNumber}</span><span class="line-content">${line}</span></div>`;
        }).join('\n');
        
        // Set the final HTML with line numbers and syntax highlighting
        codeContainer.innerHTML = codeWithLineNumbers;
        
        // Add click event to each line
        document.querySelectorAll('.code-line').forEach(line => {
            line.addEventListener('click', function() {
                const lineNumber = parseInt(this.dataset.line);
                selectLineByNumber(lineNumber);
            });
        });
    }
    
    function createTimeline(snapshots) {
        const timelineContainer = document.getElementById('timeline-container');
        
        if (!snapshots || snapshots.length === 0) {
            timelineContainer.innerHTML = '<div class="alert alert-warning">No stack recording snapshots available</div>';
            return;
        }
        
        // Track execution order of lines and create a sequence array
        const executionSequence = [];
        snapshots.forEach((snapshot, index) => {
            const lineNumber = snapshot.line || snapshot.line_number;
            executionSequence.push({
                index: index,
                line: lineNumber
            });
        });
        
        // Find actual loops in the execution sequence
        const loopConnections = [];
        for (let i = 0; i < executionSequence.length - 1; i++) {
            const current = executionSequence[i];
            const next = executionSequence[i + 1];
            
            // If next line is smaller than current, it's a backward jump (loop)
            if (next.line < current.line) {
                console.log(`Found loop: ${current.line} -> ${next.line}`);
                loopConnections.push({
                    from: current.line,
                    to: next.line
                });
            }
        }
        
        // Group snapshots by line number for display
        const lineGroups = {};
        snapshots.forEach((snapshot, index) => {
            const lineNumber = snapshot.line || snapshot.line_number;
            if (!lineGroups[lineNumber]) {
                lineGroups[lineNumber] = [];
            }
            lineGroups[lineNumber].push(index);
        });
        
        // Get unique line numbers in order of first appearance
        const orderedLines = [];
        snapshots.forEach(snapshot => {
            const lineNumber = snapshot.line || snapshot.line_number;
            if (!orderedLines.includes(lineNumber)) {
                orderedLines.push(lineNumber);
            }
        });
        
        // Clear the container and style it for proper scrolling
        timelineContainer.innerHTML = '';
        timelineContainer.style.overflowX = 'auto';
        timelineContainer.style.overflowY = 'hidden';
        timelineContainer.style.position = 'relative';
        
        // Create outer container with padding to prevent dots from being cut off
        const outerContainer = document.createElement('div');
        outerContainer.style.paddingLeft = '20px';
        outerContainer.style.paddingRight = '20px';
        outerContainer.style.position = 'relative';
        outerContainer.style.width = 'max-content';
        outerContainer.style.minWidth = '100%';
        timelineContainer.appendChild(outerContainer);
        
        // Create timeline wrapper
        const timelineWrapper = document.createElement('div');
        timelineWrapper.className = 'timeline-wrapper';
        timelineWrapper.style.position = 'relative';
        timelineWrapper.style.height = '100px';
        timelineWrapper.style.marginTop = '10px';
        
        // Set the width based on number of points (at least 70px per point plus padding)
        const timelineWidth = orderedLines.length * 70 + 40;
        timelineWrapper.style.width = `${timelineWidth}px`;
        
        outerContainer.appendChild(timelineWrapper);
        
        // Create the base timeline line
        const baseTimeline = document.createElement('div');
        baseTimeline.className = 'timeline-line';
        baseTimeline.style.position = 'absolute';
        baseTimeline.style.height = '2px';
        baseTimeline.style.backgroundColor = '#dee2e6';
        baseTimeline.style.top = '30px';
        baseTimeline.style.left = '0';
        baseTimeline.style.right = '0';
        baseTimeline.style.zIndex = '1';
        timelineWrapper.appendChild(baseTimeline);
        
        // Create SVG for lines and arcs
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.zIndex = '1';
        timelineWrapper.appendChild(svg);
        
        // Create defs for arrow markers
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.appendChild(defs);
        
        // Normal arrow marker
        const normalMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        normalMarker.setAttribute('id', 'arrow-normal');
        normalMarker.setAttribute('viewBox', '0 0 10 10');
        normalMarker.setAttribute('refX', '9');
        normalMarker.setAttribute('refY', '5');
        normalMarker.setAttribute('markerWidth', '6');
        normalMarker.setAttribute('markerHeight', '6');
        normalMarker.setAttribute('orient', 'auto');
        normalMarker.innerHTML = '<path d="M 0 0 L 10 5 L 0 10 z" fill="#6c757d"/>';
        defs.appendChild(normalMarker);
        
        // Loop arrow marker (red)
        const loopMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        loopMarker.setAttribute('id', 'arrow-loop');
        loopMarker.setAttribute('viewBox', '0 0 10 10');
        loopMarker.setAttribute('refX', '9');
        loopMarker.setAttribute('refY', '5');
        loopMarker.setAttribute('markerWidth', '6');
        loopMarker.setAttribute('markerHeight', '6');
        loopMarker.setAttribute('orient', 'auto');
        loopMarker.innerHTML = '<path d="M 0 0 L 10 5 L 0 10 z" fill="#dc3545"/>';
        defs.appendChild(loopMarker);
        
        // Calculate the point positions
        const pointPositions = {};
        const pointElements = [];
        
        // Create points for each line
        orderedLines.forEach((lineNumber, index) => {
            const pointIndices = lineGroups[lineNumber];
            const firstIndex = pointIndices[0];
            const count = pointIndices.length;
            
            // Calculate position (evenly spaced)
            const pointSpacing = timelineWidth / (orderedLines.length + 1);
            const xPos = (index + 1) * pointSpacing;
            
            // Save position for drawing lines later - create a fresh object
            pointPositions[lineNumber] = {
                x: xPos,
                index: index
            };
            
            // Determine point type
            let pointType = 'normal';
            let markerStyle = '';
            
            if (index > 0) {
                const prevLine = orderedLines[index - 1];
                // Loop back (line number decreases)
                if (lineNumber < prevLine) {
                    pointType = 'loop-back';
                    markerStyle = 'background-color: white; border: 2px solid #dc3545;';
                }
                // Jump forward (skips lines)
                else if (lineNumber > prevLine + 1) {
                    pointType = 'jump-forward';
                    markerStyle = 'background-color: #fd7e14;';
                }
            }
            
            // Normal point if no special style set
            if (!markerStyle) {
                markerStyle = 'background-color: #007bff;';
            }
            
            // Create point container
            const point = document.createElement('div');
            point.className = `timeline-point ${pointType}`;
            point.setAttribute('data-line', lineNumber);
            point.setAttribute('data-index', firstIndex);
            point.setAttribute('data-point-type', pointType);
            point.setAttribute('title', `Line ${lineNumber} (${count} snapshot${count > 1 ? 's' : ''})`);
            point.style.position = 'absolute';
            point.style.left = `${xPos}px`;
            point.style.transform = 'translateX(-50%)';
            point.style.top = '0';
            point.style.textAlign = 'center';
            point.style.cursor = 'pointer';
            point.style.width = '30px';
            point.style.zIndex = '2';
            
            // Create marker
            const marker = document.createElement('div');
            marker.className = 'timeline-marker';
            marker.style.width = '14px';
            marker.style.height = '14px';
            marker.style.borderRadius = '50%';
            marker.style.margin = '0 auto';
            marker.style.marginTop = '23px';
            marker.style.position = 'relative';
            marker.style.backgroundColor = markerStyle.includes('background-color') ? 
                markerStyle.match(/background-color: ([^;]+);/)[1] : '#007bff';
            
            if (markerStyle.includes('border')) {
                marker.style.border = markerStyle.match(/border: ([^;]+);/)[1];
            }
            
            // Add count badge if needed
            if (count > 1) {
                const badge = document.createElement('span');
                badge.className = 'badge';
                badge.textContent = count;
                badge.style.position = 'absolute';
                badge.style.top = '-6px';
                badge.style.right = '-6px';
                badge.style.backgroundColor = '#6c757d';
                badge.style.color = 'white';
                badge.style.fontSize = '9px';
                badge.style.borderRadius = '50%';
                badge.style.padding = '2px 4px';
                badge.style.minWidth = '16px';
                badge.style.textAlign = 'center';
                marker.appendChild(badge);
            }
            
            // Add line number
            const lineLabel = document.createElement('div');
            lineLabel.className = 'timeline-line-number';
            lineLabel.textContent = lineNumber;
            lineLabel.style.fontSize = '10px';
            lineLabel.style.marginTop = '6px';
            
            // Assemble point
            point.appendChild(marker);
            point.appendChild(lineLabel);
            timelineWrapper.appendChild(point);
            
            // Save reference for later - create a new object reference
            pointElements.push({
                element: point,
                marker: marker,
                line: lineNumber,
                x: xPos
            });
            
            // Add click handler
            point.addEventListener('click', function() {
                const lineNum = parseInt(this.getAttribute('data-line'));
                const snapshotIndex = parseInt(this.getAttribute('data-index'));
                selectLineByNumber(lineNum);
                displaySnapshot(snapshotIndex);
            });
        });
        
        // Draw regular connecting lines between points
        for (let i = 0; i < pointElements.length - 1; i++) {
            const current = pointElements[i];
            const next = pointElements[i + 1];
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', current.x);
            line.setAttribute('y1', '30');
            // Ensure we don't try to modify next.x directly by creating a new value
            const arrowEndX = next.x - 6;
            line.setAttribute('x2', arrowEndX);
            line.setAttribute('y2', '30');
            line.setAttribute('stroke', '#6c757d');
            line.setAttribute('stroke-width', '1.5');
            line.setAttribute('marker-end', 'url(#arrow-normal)');
            
            svg.appendChild(line);
        }
        
        // Draw loop arcs
        loopConnections.forEach(loop => {
            const fromPoint = pointPositions[loop.from];
            const toPoint = pointPositions[loop.to];
            
            if (fromPoint && toPoint) {
                const startX = fromPoint.x;
                const endX = toPoint.x;
                
                // Only draw if not adjacent points
                if (Math.abs(fromPoint.index - toPoint.index) > 1) {
                    // Calculate arc control points (for bezier curve)
                    const midX = (startX + endX) / 2;
                    const controlY = 10; // Higher curve for visibility
                    
                    // Create path element for the arc
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // Ensure we don't try to modify endX directly by creating a new value
                    const arrowEndX = endX - 6;
                    path.setAttribute('d', `M ${startX} 30 Q ${midX} ${controlY} ${arrowEndX} 30`);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', '#dc3545');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('stroke-dasharray', '3,3');
                    path.setAttribute('marker-end', 'url(#arrow-loop)');
                    path.style.zIndex = '3';
                    
                    // Append to SVG
                    svg.appendChild(path);
                    
                    console.log(`Drew loop arc from line ${loop.from} to ${loop.to}`);
                }
            }
        });
        
        // Highlight first point
        if (pointElements.length > 0) {
            const firstMarker = pointElements[0].marker;
            // Use a new marker instead of modifying style directly
            firstMarker.style.backgroundColor = '#dc3545';
        }
        
        // Log loop connections for debugging
        console.log('Loop connections:', loopConnections);
        console.log('Point positions:', pointPositions);
    }
    
    function displaySnapshot(index) {
        if (!currentStackData || !currentStackData.frames || index >= currentStackData.frames.length) {
            return;
        }
        
        selectedSnapshotIndex = index;
        const snapshot = currentStackData.frames[index];
        
        // Get line number, supporting both line and line_number attributes
        const lineNumber = snapshot.line || snapshot.line_number;
        
        // Update current line
        document.getElementById('current-line').textContent = lineNumber;
        
        // Update global counter
        updateGlobalCounter(index);
        
        // Highlight the current line in the code - the snapshot.line is in the source file's line numbers
        highlightLine(lineNumber);
        
        // Add snapshot navigation if multiple snapshots exist for this line
        addSnapshotNavigation(lineNumber, index);
        
        // Display local variables
        displayVariables(snapshot.locals, 'locals-content', 'locals-loading');
        
        // Display global variables
        displayVariables(snapshot.globals, 'globals-content', 'globals-loading');
    }
    
    function addSnapshotNavigation(lineNumber, currentIndex) {
        // Find all snapshots for this line
        const snapshotsForLine = currentStackData.frames
            .map((snapshot, index) => ({ 
                snapshot, 
                index,
                line: snapshot.line || snapshot.line_number 
            }))
            .filter(item => item.line === lineNumber);
            
        // Get the current position in the snapshots for this line
        const currentPosition = snapshotsForLine.findIndex(item => item.index === currentIndex);
        
        // Get the container where we'll insert the navigation controls
        const container = document.querySelector('.card:has(#current-line) .card-header .d-flex.align-items-center');
        
        // If there's already a navigation container, remove it
        const existingNav = document.querySelector('.snapshot-navigation');
        if (existingNav) {
            existingNav.remove();
        }
        
        // Only add navigation if there are multiple snapshots for this line
        if (snapshotsForLine.length > 1) {
            const navContainer = document.createElement('div');
            navContainer.className = 'snapshot-navigation me-2 d-flex align-items-center';
            
            navContainer.innerHTML = `
                <small class="text-muted me-2">Snapshot ${currentPosition + 1}/${snapshotsForLine.length}</small>
                <div class="btn-group btn-group-sm">
                    <button id="prev-snapshot" class="btn btn-outline-secondary" ${currentPosition === 0 ? 'disabled' : ''}>
                        <i class="bi bi-chevron-left"></i>
                    </button>
                    <button id="next-snapshot" class="btn btn-outline-secondary" ${currentPosition === snapshotsForLine.length - 1 ? 'disabled' : ''}>
                        <i class="bi bi-chevron-right"></i>
                    </button>
                </div>
            `;
            
            // Insert navigation before the tab buttons
            if (container) {
                container.insertBefore(navContainer, container.firstChild);
                
                // Add event listeners for prev/next buttons
                const prevButton = document.getElementById('prev-snapshot');
                const nextButton = document.getElementById('next-snapshot');
                
                if (prevButton && nextButton) {
                    prevButton.addEventListener('click', function() {
                        if (currentPosition > 0) {
                            displaySnapshot(snapshotsForLine[currentPosition - 1].index);
                        }
                    });
                    
                    nextButton.addEventListener('click', function() {
                        if (currentPosition < snapshotsForLine.length - 1) {
                            displaySnapshot(snapshotsForLine[currentPosition + 1].index);
                        }
                    });
                }
            }
        }
    }
    
    function displayVariables(variables, containerId, loadingId) {
        const container = document.getElementById(containerId);
        const loadingElement = document.getElementById(loadingId);
        
        // Hide loading spinner
        loadingElement.style.display = 'none';
        
        if (!variables || Object.keys(variables).length === 0) {
            container.innerHTML = '<div class="alert alert-info">No variables available</div>';
            return;
        }
        
        let html = '<div class="table-responsive"><table class="table table-sm table-hover">';
        html += '<thead><tr><th>Name</th><th>Type</th><th>Value</th></tr></thead><tbody>';
        
        for (const [name, data] of Object.entries(variables)) {
            html += `
                <tr>
                    <td><strong>${name}</strong></td>
                    <td>${data.type}</td>
                    <td>${formatValue(data.value, data.type)}</td>
                </tr>
            `;
        }
        
        html += '</tbody></table></div>';
        container.innerHTML = html;
    }
    
    function formatValue(value, type) {
        if (value === null || value === 'None') {
            return '<span class="text-muted">None</span>';
        }
        
        const isLongValue = value && value.length > 100;
        let formattedValue = '';
        
        if (type === 'str') {
            formattedValue = `<span class="text-success">"${escapeHtml(value)}"</span>`;
        } else if (type === 'int' || type === 'float') {
            formattedValue = `<span class="text-primary">${value}</span>`;
        } else if (type === 'bool') {
            formattedValue = `<span class="text-danger">${value}</span>`;
        } else if (type === 'list' || type === 'tuple' || (typeof value === 'string' && (value.startsWith('[') || value.startsWith('(')))) {
            formattedValue = `<span class="text-info">${escapeHtml(value)}</span>`;
        } else if (type === 'dict' || (typeof value === 'string' && value.startsWith('{'))) {
            formattedValue = `<span class="text-warning">${escapeHtml(value)}</span>`;
        } else {
            formattedValue = escapeHtml(value);
        }
        
        // Make large values collapsible
        if (isLongValue) {
            const shortValue = value.substring(0, 100) + '...';
            const shortFormatted = formattedValue.substring(0, formattedValue.indexOf('>') + 1) + 
                                    escapeHtml(shortValue) + 
                                    formattedValue.substring(formattedValue.lastIndexOf('<'));
            
            return `
                <div class="collapsed-value">
                    <div class="short-value">${shortFormatted} <button class="btn btn-sm btn-link p-0 toggle-value">Show more</button></div>
                    <div class="full-value" style="display:none">${formattedValue} <button class="btn btn-sm btn-link p-0 toggle-value">Show less</button></div>
                </div>
            `;
        }
        
        return formattedValue;
    }
    
    function escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
    
    function highlightLine(lineNumber) {
        // Reset all lines
        document.querySelectorAll('.code-line').forEach(line => {
            line.classList.remove('highlighted-line');
        });
        
        // Highlight the current line, accounting for the line offset
        // The lineNumber from the API is already in terms of the source file's line numbers,
        // so we don't need to adjust it further
        const lineElement = document.getElementById(`code-line-${lineNumber}`);
        if (lineElement) {
            lineElement.classList.add('highlighted-line');
            lineElement.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
    }
    
    function selectLineByNumber(lineNumber) {
        if (!currentStackData || !currentStackData.frames) return;
        
        // Find the closest snapshot for this line
        let closestIndex = 0;
        let minDistance = Infinity;
        let matchingIndices = [];
        
        // Find exact matching lines and also the closest snapshot
        currentStackData.frames.forEach((snapshot, index) => {
            // Get line number, supporting both line and line_number attributes
            const snapshotLine = snapshot.line || snapshot.line_number;
            const distance = Math.abs(snapshotLine - lineNumber);
            
            // If this line exactly matches, add it to matching indices
            if (snapshotLine === lineNumber) {
                matchingIndices.push(index);
            }
            
            // Also keep track of closest line for fallback
            if (distance < minDistance) {
                minDistance = distance;
                closestIndex = index;
            }
        });
        
        // If no exact matches, use the closest match
        if (matchingIndices.length === 0) {
            matchingIndices.push(closestIndex);
        }
        
        // Display the first matching snapshot
        displaySnapshot(matchingIndices[0]);
        
        // Update timeline markers
        updateTimelineMarkers(matchingIndices[0]);
    }

    // Add event listener for toggle buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('toggle-value')) {
            const container = e.target.closest('.collapsed-value');
            const shortValue = container.querySelector('.short-value');
            const fullValue = container.querySelector('.full-value');
            
            if (shortValue.style.display === 'none') {
                shortValue.style.display = 'block';
                fullValue.style.display = 'none';
            } else {
                shortValue.style.display = 'none';
                fullValue.style.display = 'block';
            }
        }
    });

    function setupPlaybackControls() {
        const playButton = document.getElementById('play-stack');
        const prevButton = document.getElementById('prev-stack');
        const nextButton = document.getElementById('next-stack');
        
        // Play button click handler
        playButton.addEventListener('click', function() {
            if (!isPlaying) {
                // Start playback
                isPlaying = true;
                playButton.innerHTML = '<i class="bi bi-pause-fill"></i>';
                
                // If we're at the end, start from beginning
                if (selectedSnapshotIndex >= currentStackData.frames.length - 1) {
                    selectedSnapshotIndex = 0;
                }
                
                // Play next snapshot every 500ms
                playInterval = setInterval(() => {
                    if (selectedSnapshotIndex < currentStackData.frames.length - 1) {
                        selectedSnapshotIndex++;
                        displaySnapshot(selectedSnapshotIndex);
                        updateTimelineMarkers(selectedSnapshotIndex);
                    } else {
                        // Stop at the end
                        stopPlayback();
                    }
                }, 500);
            } else {
                stopPlayback();
            }
        });
        
        // Previous button click handler
        prevButton.addEventListener('click', function() {
            stopPlayback();
            if (selectedSnapshotIndex > 0) {
                selectedSnapshotIndex--;
                displaySnapshot(selectedSnapshotIndex);
                updateTimelineMarkers(selectedSnapshotIndex);
            }
        });
        
        // Next button click handler
        nextButton.addEventListener('click', function() {
            stopPlayback();
            if (selectedSnapshotIndex < currentStackData.frames.length - 1) {
                selectedSnapshotIndex++;
                displaySnapshot(selectedSnapshotIndex);
                updateTimelineMarkers(selectedSnapshotIndex);
            }
        });
    }

    function updateTimelineMarkers(currentIndex) {
        if (!currentStackData || !currentStackData.frames) return;
        
        const snapshot = currentStackData.frames[currentIndex];
        if (!snapshot) return;
        
        const lineNumber = snapshot.line || snapshot.line_number;
        
        // Reset all timeline points to their original colors
        document.querySelectorAll('.timeline-point').forEach(point => {
            const marker = point.querySelector('.timeline-marker');
            const pointType = point.getAttribute('data-point-type');
            
            if (pointType === 'loop-back') {
                marker.style.backgroundColor = 'white';
                marker.style.border = '2px solid #dc3545';
            } else if (pointType === 'jump-forward') {
                marker.style.backgroundColor = '#fd7e14';
            } else {
                marker.style.backgroundColor = '#007bff';
            }
        });
        
        // Highlight the point for the current line
        document.querySelectorAll(`.timeline-point[data-line="${lineNumber}"]`).forEach(point => {
            const marker = point.querySelector('.timeline-marker');
            marker.style.backgroundColor = '#dc3545';
            
            if (point.getAttribute('data-point-type') === 'loop-back') {
                marker.style.border = '2px solid #dc3545';
            }
        });
    }

    function stopPlayback() {
        if (isPlaying) {
            isPlaying = false;
            clearInterval(playInterval);
            document.getElementById('play-stack').innerHTML = '<i class="bi bi-play-fill"></i>';
        }
    }

    function updateGlobalCounter(currentIndex) {
        if (currentStackData && currentStackData.frames) {
            const total = currentStackData.frames.length;
            document.getElementById('global-counter').textContent = `${currentIndex + 1}/${total}`;
        }
    }

    // Create a function to recalculate connections when window resizes
    function recalculateConnections() {
        const timelineContainer = document.getElementById('timeline-container');
        const connectionsContainer = timelineContainer.querySelector('.timeline-connections');
        const points = timelineContainer.querySelectorAll('.timeline-point');
        
        if (!connectionsContainer || points.length <= 1) return;
        
        // Clear existing SVG
        connectionsContainer.innerHTML = '';
        
        // Create new SVG container
        const svgContainer = document.createElement('svg');
        svgContainer.style.position = 'absolute';
        svgContainer.style.top = '0';
        svgContainer.style.left = '0';
        svgContainer.style.width = '100%';
        svgContainer.style.height = '100%';
        svgContainer.style.overflow = 'visible';
        svgContainer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        connectionsContainer.appendChild(svgContainer);
        
        // Draw connections between consecutive points
        for (let i = 0; i < points.length - 1; i++) {
            const currentPoint = points[i];
            const nextPoint = points[i + 1];
            
            // Get marker positions
            const currentMarker = currentPoint.querySelector('.timeline-marker');
            const nextMarker = nextPoint.querySelector('.timeline-marker');
            
            // Calculate positions for the line
            const currentRect = currentMarker.getBoundingClientRect();
            const nextRect = nextMarker.getBoundingClientRect();
            const containerRect = connectionsContainer.getBoundingClientRect();
            
            // Get center points relative to the connections container
            const x1 = currentRect.left + (currentRect.width / 2) - containerRect.left;
            const y1 = currentRect.top + (currentRect.height / 2) - containerRect.top;
            const x2 = nextRect.left + (nextRect.width / 2) - containerRect.left;
            const y2 = nextRect.top + (nextRect.height / 2) - containerRect.top;
            
            // Create line element
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#ccc');
            line.setAttribute('stroke-width', '1.5');
            
            // Add arrow marker for direction
            const arrowId = `arrow-${i}`;
            
            // Create arrow marker definition
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', arrowId);
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('orient', 'auto');
            
            // Create arrow path
            const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowPath.setAttribute('fill', '#ccc');
            
            // Add path to marker
            marker.appendChild(arrowPath);
            
            // Add marker definition to SVG
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.appendChild(marker);
            svgContainer.appendChild(defs);
            
            // Set marker end for the line
            line.setAttribute('marker-end', `url(#${arrowId})`);
            
            // Check for loop-back
            if (currentPoint.classList.contains('loop-back')) {
                line.setAttribute('stroke', '#e74c3c');
                line.setAttribute('stroke-dasharray', '3,3');
                arrowPath.setAttribute('fill', '#e74c3c');
            }
            // Check for jump-forward
            else if (currentPoint.classList.contains('jump-forward')) {
                line.setAttribute('stroke', '#f39c12');
                arrowPath.setAttribute('fill', '#f39c12');
            }
            
            // Add line to SVG
            svgContainer.appendChild(line);
        }
    }

    // Add window resize event listener
    window.addEventListener('resize', debounce(recalculateConnections, 200));

    // Debounce function to limit resize calculations
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }

    // Call recalculate connections after a short delay to ensure DOM is fully rendered
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(recalculateConnections, 500);
    });
</script>

<style>
    /* Container styles */
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100vh;
    }

    .stack-trace-container {
        height: 100vh;
        padding: 1rem;
        overflow: hidden;
    }

    /* Adjust card heights to fit in container */
    .card {
        display: flex;
        flex-direction: column;
    }

    .card-body {
        flex: 1;
        overflow: hidden;
    }

    /* Ensure code and variables containers scroll independently */
    #code-container {
        height: 100% !important;
        overflow: auto;
    }

    #locals-container, #globals-container {
        height: 100% !important;
        overflow: auto;
    }

    .code-line {
        white-space: pre;
        line-height: 1.1;
        display: flex;
        align-items: flex-start;
        padding: 1px 0;
    }
    
    .line-number {
        min-width: 3em;
        text-align: right;
        padding-right: 0.5em;
        color: #999;
        user-select: none;
        border-right: 1px solid #ddd;
        margin-right: 0.5em;
        flex-shrink: 0;
    }
    
    .line-content {
        white-space: pre;
        flex-grow: 1;
    }
    
    .highlighted-line {
        background-color: rgba(255, 0, 0, 0.15);
        border-left: 3px solid red;
        padding-top: 2px;
        padding-bottom: 2px;
    }
    
    .highlighted-line .line-number {
        color: #d63031;
        font-weight: bold;
    }
    
    .timeline {
        background-color: #f8f9fa;
        border-radius: 4px;
    }
    
    #code-container {
        font-family: monospace;
        white-space: pre;
        padding: 0.5rem;
        font-size: 0.85em;
        line-height: 0;
    }

    .position-absolute {
        position: absolute !important;
    }
    
    .top-0 {
        top: 0 !important;
    }
    
    .start-100 {
        left: 100% !important;
    }
    
    .translate-middle {
        transform: translate(-50%, -50%) !important;
    }
    
    .rounded-pill {
        border-radius: 50rem !important;
    }
    
    .badge {
        display: inline-block;
        padding: 0.25em 0.4em;
        font-size: 75%;
        font-weight: 700;
        line-height: 1;
        text-align: center;
        white-space: nowrap;
        vertical-align: baseline;
        border-radius: 0.25rem;
    }
    
    .bg-secondary {
        background-color: #6c757d !important;
        color: white;
    }
    
    /* Collapsible value styles */
    .toggle-value {
        font-size: 0.8em;
        vertical-align: middle;
        text-decoration: none;
    }
    
    .toggle-value:hover {
        text-decoration: underline;
    }
    
    .short-value, .full-value {
        word-break: break-word;
    }
    
    /* Snapshot navigation styles */
    .snapshot-navigation {
        margin-right: 1rem;
        border-right: 1px solid #ddd;
        padding-right: 1rem;
    }
    
    /* Playback controls styles */
    .btn-group .btn {
        padding: 0.25rem 0.5rem;
    }
    
    .btn-group .btn i {
        font-size: 0.8em;
    }
    
    /* Bootstrap icon replacements */
    .bi-chevron-left:before {
        content: "◀";
        font-size: 0.7em;
    }
    
    .bi-chevron-right:before {
        content: "▶";
        font-size: 0.7em;
    }
    
    .bi-play-fill:before {
        content: "▶";
        font-size: 0.7em;
    }
    
    .bi-pause-fill:before {
        content: "⏸";
        font-size: 0.7em;
    }
    
    .me-2 {
        margin-right: 0.5rem !important;
    }
</style>
{% endblock %} 