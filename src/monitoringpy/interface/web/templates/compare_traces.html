{% extends "base.html" %}

{% block head %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
<!-- Add highlight.js for syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
{% endblock %}

{% block content %}
<div class="container-fluid trace-comparison-container">
    <!-- Header with trace selection -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <div class="row align-items-center">
                        <div class="col-md-4">
                            <h4 class="mb-0">Compare Stack Traces</h4>
                        </div>
                        <div class="col-md-8">
                            <div class="row g-2">
                                <div class="col-md-5">
                                    <label for="trace1-select" class="form-label small">Trace 1:</label>
                                    <select id="trace1-select" class="form-select form-select-sm">
                                        <option value="">Select first trace...</option>
                                    </select>
                                </div>
                                <div class="col-md-5">
                                    <label for="trace2-select" class="form-label small">Trace 2:</label>
                                    <select id="trace2-select" class="form-select form-select-sm">
                                        <option value="">Select second trace...</option>
                                    </select>
                                </div>
                                <div class="col-md-2 d-flex align-items-end">
                                    <button id="compare-btn" class="btn btn-primary btn-sm w-100" disabled>
                                        <i class="bi bi-arrow-left-right"></i> Compare
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Split view: Code on left, Graph on right -->
    <div class="row">
        <!-- Code Column -->
        <div class="col-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Source Code</h5>
                </div>
                <div class="card-body p-0">
                    <!-- Two code panels side by side -->
                    <div class="row g-0 h-100">
                        <div class="col-6 border-end">
                            <div class="d-flex justify-content-between align-items-center p-2 bg-light border-bottom">
                                <small class="text-muted"><strong>Version 1</strong></small>
                            </div>
                            <pre><code id="code-container-v1" class="language-python" style="height: calc(70vh - 40px); overflow: auto; font-size: 13px; line-height: 1.2; margin: 0;"></code></pre>
                        </div>
                        <div class="col-6">
                            <div class="d-flex justify-content-between align-items-center p-2 bg-light border-bottom">
                                <small class="text-muted"><strong>Version 2</strong></small>
                            </div>
                            <pre><code id="code-container-v2" class="language-python" style="height: calc(70vh - 40px); overflow: auto; font-size: 13px; line-height: 1.2; margin: 0;"></code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Graph Column -->
        <div class="col-6">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Execution Diff Graph</h5>
                    <div class="btn-group btn-group-sm" role="group">
                        <button id="reset-graph-btn" class="btn btn-outline-secondary" title="Reset Graph View">
                            <i class="bi bi-arrow-clockwise"></i>
                        </button>
                        <button id="toggle-controls-btn" class="btn btn-outline-secondary" title="Toggle Controls">
                            <i class="bi bi-gear"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body p-0 position-relative">
                    <div id="graph-container" style="height: 70vh; width: 100%; background: #f8f9fa;">
                        <div id="loading-message" class="d-flex align-items-center justify-content-center h-100">
                            <div class="text-center">
                                <div class="spinner-border text-primary mb-3" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="text-muted">Select two traces to compare</p>
                            </div>
                        </div>
                        <svg id="graph-svg" style="width: 100%; height: 100%; display: none;"></svg>
                    </div>

                    <!-- Graph Controls Panel -->
                    <div id="control-panel" class="position-absolute" style="top: 10px; left: 10px; z-index: 10; display: none;">
                        <div class="card card-body p-2" style="font-size: 12px; max-width: 200px;">
                            <div class="control-header d-flex justify-content-between align-items-center mb-2" style="cursor: pointer;">
                                <strong>Graph Controls</strong>
                                <i id="control-toggle" class="bi bi-chevron-down"></i>
                            </div>
                            <div id="control-content">
                                <div class="mb-2">
                                    <label class="form-label mb-1">Variable View:</label>
                                    <select id="variable-selector" class="form-select form-select-sm">
                                        <option value="">Node IDs</option>
                                    </select>
                                </div>
                                <div class="mb-2">
                                    <label class="form-label mb-1">Node Filters:</label>
                                    <div class="form-check form-check-sm">
                                        <input class="form-check-input" type="checkbox" id="filter-common" checked>
                                        <label class="form-check-label" for="filter-common">Common</label>
                                    </div>
                                    <div class="form-check form-check-sm">
                                        <input class="form-check-input" type="checkbox" id="filter-modified" checked>
                                        <label class="form-check-label" for="filter-modified">Modified</label>
                                    </div>
                                    <div class="form-check form-check-sm">
                                        <input class="form-check-input" type="checkbox" id="filter-only1" checked>
                                        <label class="form-check-label" for="filter-only1">Only V1</label>
                                    </div>
                                    <div class="form-check form-check-sm">
                                        <input class="form-check-input" type="checkbox" id="filter-only2" checked>
                                        <label class="form-check-label" for="filter-only2">Only V2</label>
                                    </div>
                                </div>
                                <button id="center-graph-btn" class="btn btn-outline-primary btn-sm w-100">
                                    <i class="bi bi-bullseye"></i> Center
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Graph Stats -->
                    <div id="graph-stats" class="position-absolute" style="top: 10px; right: 10px; z-index: 10; display: none;">
                        <div class="card card-body p-2" style="font-size: 11px; opacity: 0.9;">
                            <div id="stats-content"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Tooltip for graph elements -->
<div id="tooltip" class="position-absolute" style="
    background: rgba(0, 0, 0, 0.8); 
    color: white; 
    padding: 8px; 
    border-radius: 4px; 
    font-size: 12px; 
    pointer-events: none; 
    z-index: 1000; 
    opacity: 0; 
    transition: opacity 0.3s;
    max-width: 300px;
"></div>
{% endblock %}

{% block scripts %}
<script>
// Global variables
let trace1Data = null;
let trace2Data = null;
let editGraphData = null;
let graphSvg = null;
let simulation = null;
let selectedVariable = '';
let availableVariables = [];
let currentTransform = d3.zoomIdentity;
let userNodePositions = {};

// Color scheme for different node/edge states
const stateColors = {
    'common': '#6c757d',      // Gray for common nodes/edges
    'modified': '#fd7e14',    // Orange for modified nodes
    'only1': '#dc3545',       // Red for only in trace 1
    'only2': '#28a745'        // Green for only in trace 2
};

document.addEventListener('DOMContentLoaded', function() {
    initializeInterface();
    loadTraces();
});

function initializeInterface() {
    // Set up event listeners
    document.getElementById('trace1-select').addEventListener('change', updateCompareButton);
    document.getElementById('trace2-select').addEventListener('change', updateCompareButton);
    document.getElementById('compare-btn').addEventListener('click', performComparison);
    
    // Graph controls
    document.getElementById('reset-graph-btn').addEventListener('click', resetGraphView);
    document.getElementById('toggle-controls-btn').addEventListener('click', toggleControlsPanel);
    document.getElementById('center-graph-btn').addEventListener('click', centerGraph);
    
    // Control panel toggle
    document.querySelector('.control-header').addEventListener('click', function() {
        const content = document.getElementById('control-content');
        const icon = document.getElementById('control-toggle');
        const isCollapsed = content.style.display === 'none';
        
        content.style.display = isCollapsed ? 'block' : 'none';
        icon.className = isCollapsed ? 'bi bi-chevron-down' : 'bi bi-chevron-up';
    });
    
    // Variable selector
    document.getElementById('variable-selector').addEventListener('change', function() {
        selectedVariable = this.value;
        if (editGraphData) {
            updateGraphVisualization(); // Update graph with new variable labels
        }
    });
    
    // Filter checkboxes
    ['filter-common', 'filter-modified', 'filter-only1', 'filter-only2'].forEach(id => {
        document.getElementById(id).addEventListener('change', function() {
            if (editGraphData) updateGraphVisualization();
        });
    });
}

async function loadTraces() {
    try {
        // Load all function calls with stack recordings
        const response = await fetch(getApiUrl('/api/function-calls'));
        const data = await response.json();
        
        // Filter to get only function calls with stack recordings
        const tracesWithRecordings = data.function_calls.filter(func => func.has_stack_recording);
        
        // Populate both dropdowns
        populateTraceDropdown('trace1-select', tracesWithRecordings);
        populateTraceDropdown('trace2-select', tracesWithRecordings);
        
    } catch (error) {
        console.error('Error loading traces:', error);
        showError('Failed to load traces');
    }
}

function populateTraceDropdown(selectId, traces) {
    const select = document.getElementById(selectId);
    
    // Clear existing options except the first one
    select.innerHTML = '<option value="">Select trace...</option>';
    
    traces.forEach(trace => {
        const option = document.createElement('option');
        option.value = trace.id;
        
        const timestamp = trace.start_time ? new Date(trace.start_time).toLocaleString() : 'N/A';
        const duration = trace.duration ? `${trace.duration.toFixed(2)}s` : 'N/A';
        
        option.textContent = `${trace.function} (${trace.file.split('/').pop()}:${trace.line}) - ${timestamp}`;
        option.title = `Duration: ${duration}, File: ${trace.file}`;
        
        select.appendChild(option);
    });
}

function updateCompareButton() {
    const trace1Id = document.getElementById('trace1-select').value;
    const trace2Id = document.getElementById('trace2-select').value;
    const compareBtn = document.getElementById('compare-btn');
    
    compareBtn.disabled = !trace1Id || !trace2Id || trace1Id === trace2Id;
}

async function performComparison() {
    const trace1Id = document.getElementById('trace1-select').value;
    const trace2Id = document.getElementById('trace2-select').value;
    
    if (!trace1Id || !trace2Id) return;
    
    try {
        showLoading('Generating comparison...');
        
        // Load both traces
        const [trace1Response, trace2Response] = await Promise.all([
            fetch(getApiUrl(`/api/stack-recording/${trace1Id}`)),
            fetch(getApiUrl(`/api/stack-recording/${trace2Id}`))
        ]);
        
        trace1Data = await trace1Response.json();
        trace2Data = await trace2Response.json();
        
        console.log('Traces loaded, generating edit graph...');
        
        // Generate edit graph
        await generateEditGraph();
        
        // Display both code versions
        displayBothCodes();
        
        // Show graph controls
        document.getElementById('control-panel').style.display = 'block';
        document.getElementById('graph-stats').style.display = 'block';
        
        console.log('Comparison complete!');
        
    } catch (error) {
        console.error('Error performing comparison:', error);
        hideLoading(); // Ensure loading is hidden on error
        showError('Failed to compare traces: ' + error.message);
    }
}

async function generateEditGraph() {
    try {
        // Call the backend to generate edit graph
        const response = await fetch(getApiUrl('/api/compare-traces'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                trace1_id: document.getElementById('trace1-select').value,
                trace2_id: document.getElementById('trace2-select').value
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        editGraphData = await response.json();
        
        // Extract variables and update selector
        extractAndPopulateVariables();
        
        // Render the graph
        updateGraphVisualization();
        
    } catch (error) {
        console.error('Error generating edit graph:', error);
        // Fall back to client-side generation if needed
        generateEditGraphClientSide();
    }
}

function generateEditGraphClientSide() {
    // Simple client-side edit graph generation as fallback
    if (!trace1Data || !trace2Data) return;
    
    const nodes = {};
    const edges = [];
    
    // Convert trace data to simple graph format
    const trace1Lines = trace1Data.frames.map(f => f.line);
    const trace2Lines = trace2Data.frames.map(f => f.line);
    
    // Create nodes for all unique lines
    const allLines = [...new Set([...trace1Lines, ...trace2Lines])];
    allLines.forEach((line, idx) => {
        nodes[idx.toString()] = {  // Use string IDs consistently
            id: idx.toString(),
            line1: trace1Lines.includes(line) ? line : null,
            line2: trace2Lines.includes(line) ? line : null,
            state: trace1Lines.includes(line) && trace2Lines.includes(line) ? 'common' : 
                   trace1Lines.includes(line) ? 'only1' : 'only2'
        };
    });
    
    // Create simple edges based on execution order
    for (let i = 0; i < allLines.length - 1; i++) {
        edges.push([i.toString(), (i + 1).toString(), { state: 'common' }]);
    }
    
    editGraphData = { nodes, edges };
    extractAndPopulateVariables();
    updateGraphVisualization();
}

function extractAndPopulateVariables() {
    availableVariables = [];
    
    if (!editGraphData) return;
    
    // Extract variables from node data
    Object.values(editGraphData.nodes).forEach(node => {
        if (node.vars1) {
            node.vars1.forEach(varObj => {
                Object.keys(varObj).forEach(varName => {
                    if (!availableVariables.includes(varName)) {
                        availableVariables.push(varName);
                    }
                });
            });
        }
        if (node.vars2) {
            node.vars2.forEach(varObj => {
                Object.keys(varObj).forEach(varName => {
                    if (!availableVariables.includes(varName)) {
                        availableVariables.push(varName);
                    }
                });
            });
        }
    });
    
    // Sort variables
    availableVariables.sort();
    
    // Update variable selector
    const selector = document.getElementById('variable-selector');
    selector.innerHTML = '<option value="">Node IDs</option>';
    
    availableVariables.forEach(variable => {
        const option = document.createElement('option');
        option.value = variable;
        option.textContent = variable;
        selector.appendChild(option);
    });
}

function updateGraphVisualization() {
    if (!editGraphData) return;
    
    // Apply filters
    const filteredData = applyFilters(editGraphData);
    
    // Render graph with D3
    renderGraph(filteredData);
    
    // Update stats
    updateGraphStats(filteredData);
    
    // Update edge labels after rendering
    setTimeout(() => updateEdgeLabels(), 100); // Small delay to ensure DOM is ready
}

function applyFilters(graphData) {
    const filters = {
        common: document.getElementById('filter-common').checked,
        modified: document.getElementById('filter-modified').checked,
        only1: document.getElementById('filter-only1').checked,
        only2: document.getElementById('filter-only2').checked
    };
    
    // Filter nodes - graphData.nodes is now a dict
    const filteredNodes = {};
    Object.entries(graphData.nodes).forEach(([id, node]) => {
        if (filters[node.state]) {
            filteredNodes[id] = node;
        }
    });
    
    // Filter edges - graphData.edges is now an array of [from, to, edgeData] tuples
    const nodeIds = new Set(Object.keys(filteredNodes));
    const filteredEdges = graphData.edges.filter(([from, to]) => 
        nodeIds.has(from.toString()) && nodeIds.has(to.toString())
    );
    
    return { nodes: filteredNodes, edges: filteredEdges };
}

function renderGraph(graphData) {
    const container = document.getElementById('graph-container');
    const svg = d3.select('#graph-svg');
    
    // Show SVG and hide loading FIRST
    hideLoading();
    document.getElementById('graph-svg').style.display = 'block';
    
    console.log('Starting graph render...');
    
    // Clear previous content
    svg.selectAll('*').remove();
    
    // Set up SVG dimensions
    const containerRect = container.getBoundingClientRect();
    const width = containerRect.width;
    const height = containerRect.height;
    
    console.log('Canvas dimensions:', width, 'x', height);
    
    svg.attr('width', width).attr('height', height);
    
    // Add arrow marker definitions
    const defs = svg.append('defs');
    
    // Create arrow marker for each state color
    Object.entries(stateColors).forEach(([state, color]) => {
        defs.append('marker')
            .attr('id', `arrow-${state}`)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 25) // Position arrow at edge of circle (radius 20 + margin)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', color);
    });
    
    // Create zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', function(event) {
            currentTransform = event.transform;
            graphGroup.attr('transform', currentTransform);
        });
    
    svg.call(zoom);
    
    // Create main group for graph content
    const graphGroup = svg.append('g').attr('class', 'graph-content');
    
    // Prepare node and link data
    const nodes = Object.entries(graphData.nodes).map(([id, node]) => ({
        id: id.toString(), // Ensure ID is string
        ...node,
        x: userNodePositions[id]?.x || Math.random() * width,
        y: userNodePositions[id]?.y || Math.random() * height
    }));
    
    const links = graphData.edges.map(([from, to, edgeData]) => ({
        source: from.toString(), // Ensure source ID is string
        target: to.toString(),   // Ensure target ID is string
        ...edgeData
    }));
    
    console.log('Nodes:', nodes.length, 'Links:', links.length);
    console.log('Sample node:', nodes[0]);
    console.log('Sample link:', links[0]);
    
    // Create force simulation
    simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));
    
    // Pre-process links to detect multiple edges between same nodes and add curvature
    const linkCounts = new Map();
    const linkIndices = new Map();
    
    // Count links between each pair of nodes
    links.forEach(link => {
        const sourceId = link.source.id || link.source;
        const targetId = link.target.id || link.target;
        const key = `${Math.min(sourceId, targetId)}-${Math.max(sourceId, targetId)}`;
        
        if (!linkCounts.has(key)) {
            linkCounts.set(key, 0);
            linkIndices.set(key, 0);
        }
        linkCounts.set(key, linkCounts.get(key) + 1);
    });
    
    // Assign curvature to each link
    links.forEach(link => {
        const sourceId = link.source.id || link.source;
        const targetId = link.target.id || link.target;
        const key = `${Math.min(sourceId, targetId)}-${Math.max(sourceId, targetId)}`;
        const count = linkCounts.get(key);
        const index = linkIndices.get(key);
        
        if (count > 1) {
            // Multiple links between same nodes - apply curvature
            const curvatureStep = 40; // pixels of curvature
            link.curvature = (index - (count - 1) / 2) * curvatureStep;
        } else {
            // Single link - no curvature needed
            link.curvature = 0;
        }
        
        linkIndices.set(key, index + 1);
    });

    // Create links with arrows as curved paths
    const link = graphGroup.append('g')
        .selectAll('path')
        .data(links)
        .enter().append('path')
        .attr('fill', 'none')
        .attr('stroke', d => stateColors[d.state] || '#666')
        .attr('stroke-width', 2)
        .attr('stroke-opacity', 0.8)
        .attr('marker-end', d => `url(#arrow-${d.state})`);
    
    // Create nodes
    const node = graphGroup.append('g')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('r', 20)
        .attr('fill', d => stateColors[d.state] || '#999')
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .style('cursor', 'pointer')
        .on('mouseover', showNodeTooltip)
        .on('mouseout', hideTooltip)
        .on('click', function(event, d) { 
            event.stopPropagation();
            highlightNodeInCode(event, d); 
        })
        .call(d3.drag()
            .on('start', dragStarted)
            .on('drag', dragged)
            .on('end', dragEnded));
    
    // Add node labels
    const nodeLabels = graphGroup.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .text(d => getNodeLabel(d))
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'central')
        .attr('fill', '#fff')
        .attr('font-size', '12px')
        .attr('font-weight', 'bold')
        .attr('pointer-events', 'none');
    
    // Create edge labels for variable changes
    const edgeLabels = graphGroup.append('g').attr('class', 'edge-labels')
        .selectAll('g')
        .data(links)
        .enter().append('g')
        .attr('class', 'edge-label-group');
    
    // Add background rectangles for edge labels
    edgeLabels.append('rect')
        .attr('class', 'edge-label-background')
        .attr('fill', 'rgba(255, 255, 255, 0.9)')
        .attr('stroke', '#666')
        .attr('stroke-width', 0.5)
        .attr('rx', 3);
    
    // Add text for edge labels
    edgeLabels.append('text')
        .attr('class', 'edge-label')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'central')
        .attr('font-size', '10px')
        .attr('font-family', 'monospace')
        .attr('fill', '#333')
        .style('pointer-events', 'none');
    
    // Update positions on simulation tick
    simulation.on('tick', function() {
        link.attr('d', d => {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const dr = Math.sqrt(dx * dx + dy * dy);
            
            if (d.curvature === 0) {
                // Straight line
                return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
            } else {
                // Curved line
                // Calculate the midpoint
                const midX = (d.source.x + d.target.x) / 2;
                const midY = (d.source.y + d.target.y) / 2;
                
                // Calculate perpendicular offset for curve
                const length = Math.sqrt(dx * dx + dy * dy);
                const offsetX = (-dy / length) * d.curvature;
                const offsetY = (dx / length) * d.curvature;
                
                const controlX = midX + offsetX;
                const controlY = midY + offsetY;
                
                return `M${d.source.x},${d.source.y}Q${controlX},${controlY} ${d.target.x},${d.target.y}`;
            }
        });
        
        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);
        
        nodeLabels
            .attr('x', d => d.x)
            .attr('y', d => d.y);
        
        // Update edge label positions (account for curves)
        edgeLabels.attr('transform', d => {
            if (d.curvature === 0) {
                // Straight line - use simple midpoint
                const midX = (d.source.x + d.target.x) / 2;
                const midY = (d.source.y + d.target.y) / 2;
                return `translate(${midX}, ${midY})`;
            } else {
                // Curved line - position label at curve midpoint
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const midX = (d.source.x + d.target.x) / 2;
                const midY = (d.source.y + d.target.y) / 2;
                const length = Math.sqrt(dx * dx + dy * dy);
                const offsetX = (-dy / length) * (d.curvature * 0.5);
                const offsetY = (dx / length) * (d.curvature * 0.5);
                
                return `translate(${midX + offsetX}, ${midY + offsetY})`;
            }
        });
        
        // Update edge label backgrounds
        edgeLabels.select('rect').each(function(d) {
            const textElement = d3.select(this.parentNode).select('text').node();
            if (textElement) {
                const bbox = textElement.getBBox();
                d3.select(this)
                    .attr('x', bbox.x - 3)
                    .attr('y', bbox.y - 1)
                    .attr('width', bbox.width + 6)
                    .attr('height', bbox.height + 2);
            }
        });
    });
    
    // Update edge labels when variable selection changes
    updateEdgeLabels();
    
    // Store SVG reference for other functions
    graphSvg = svg;
    
    console.log('Graph render complete!');
}

function getNodeLabel(node) {
    if (selectedVariable && selectedVariable !== '') {
        // Try to get variable value from either version
        const value1 = getVariableValueFromNode(node, selectedVariable, 'v1');
        const value2 = getVariableValueFromNode(node, selectedVariable, 'v2');
        return value1 || value2 || node.id;
    }
    return node.line1 || node.line2 || node.id;
}

function getVariableValueFromNode(node, variable, version) {
    const vars = version === 'v1' ? node.vars1 : node.vars2;
    if (!vars || !Array.isArray(vars)) return null;
    
    for (const varObj of vars) {
        if (varObj && varObj[variable] !== undefined) {
            return String(varObj[variable]).slice(0, 50) + (String(varObj[variable]).length > 50 ? '...' : '');
        }
    }
    return null;
}

function getAvailableVariables(node, version) {
    const vars = version === 'v1' ? node.vars1 : node.vars2;
    if (!vars || !Array.isArray(vars)) return [];
    
    const variables = new Set();
    vars.forEach(varObj => {
        if (varObj && typeof varObj === 'object') {
            Object.keys(varObj).forEach(key => variables.add(key));
        }
    });
    
    return Array.from(variables);
}

function showNodeTooltip(event, d) {
    const tooltip = document.getElementById('tooltip');
    
    let content = `<strong>Node ${d.id}</strong><br/>`;
    content += `<strong>State:</strong> ${d.state}<br/>`;
    
    if (d.line1) content += `<strong>Line V1:</strong> ${d.line1}<br/>`;
    if (d.line2) content += `<strong>Line V2:</strong> ${d.line2}<br/>`;
    
    // Add variable information
    if (selectedVariable && selectedVariable !== '') {
        const value1 = getVariableValueFromNode(d, selectedVariable, 'v1');
        const value2 = getVariableValueFromNode(d, selectedVariable, 'v2');
        
        content += `<br/><strong>${selectedVariable}:</strong><br/>`;
        if (value1) content += `V1: ${value1}<br/>`;
        if (value2) content += `V2: ${value2}<br/>`;
    } else {
        // Show a summary of available variables
        const vars1 = getAvailableVariables(d, 'v1');
        const vars2 = getAvailableVariables(d, 'v2');
        
        if (vars1.length > 0 || vars2.length > 0) {
            content += `<br/><strong>Variables:</strong><br/>`;
            if (vars1.length > 0) content += `V1: ${vars1.join(', ')}<br/>`;
            if (vars2.length > 0) content += `V2: ${vars2.join(', ')}<br/>`;
        }
    }
    
    tooltip.innerHTML = content;
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY + 10) + 'px';
    tooltip.style.opacity = 1;
}

function hideTooltip() {
    document.getElementById('tooltip').style.opacity = 0;
}

function highlightNodeInCode(event, d) {
    console.log('Node clicked:', d);
    
    // Highlight the corresponding lines in both code panels
    let line1 = d.line1;
    let line2 = d.line2;
    
    console.log('Original graph node lines - V1:', line1, 'V2:', line2);
    
    // Convert adjusted trace line numbers back to displayed code line numbers
    // The graph nodes have adjusted line numbers, but the displayed code uses original file line numbers
    if (line1 && trace1Data && trace1Data.function.code) {
        const firstLineNo1 = getFirstLineNumber(trace1Data.function.code);
        line1 = line1 + firstLineNo1 - 1; // Convert back to original file line number
        console.log('Converted V1 line:', d.line1, '->', line1, '(offset:', firstLineNo1, ')');
    }
    
    if (line2 && trace2Data && trace2Data.function.code) {
        const firstLineNo2 = getFirstLineNumber(trace2Data.function.code);
        line2 = line2 + firstLineNo2 - 1; // Convert back to original file line number
        console.log('Converted V2 line:', d.line2, '->', line2, '(offset:', firstLineNo2, ')');
    }
    
    console.log('Highlighting lines - V1:', line1, 'V2:', line2);
    
    // Debug: Check if code containers have content
    const v1Container = document.querySelector('#code-container-v1');
    const v2Container = document.querySelector('#code-container-v2');
    console.log('V1 container content length:', v1Container?.innerHTML?.length || 0);
    console.log('V2 container content length:', v2Container?.innerHTML?.length || 0);
    
    // Debug: Check what line numbers actually exist in the code containers
    const v1Lines = Array.from(document.querySelectorAll('#code-container-v1 .code-line')).map(el => el.dataset.line);
    const v2Lines = Array.from(document.querySelectorAll('#code-container-v2 .code-line')).map(el => el.dataset.line);
    console.log('Available V1 lines:', v1Lines.slice(0, 10), '...');
    console.log('Available V2 lines:', v2Lines.slice(0, 10), '...');
    
    // Clear existing highlights first
    document.querySelectorAll('.highlighted-line').forEach(el => {
        el.classList.remove('highlighted-line');
    });
    
    // Highlight line in version 1 if it exists
    if (line1) {
        const v1LineElement = document.querySelector(`#code-line-v1-${line1}`);
        console.log('Looking for V1 line selector:', `#code-line-v1-${line1}`);
        console.log('V1 line element found:', !!v1LineElement);
        
        if (v1LineElement) {
            v1LineElement.classList.add('highlighted-line');
            v1LineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
            // Fallback: try to find the closest line number
            const closestV1Line = findClosestLine(line1, v1Lines);
            if (closestV1Line) {
                const fallbackElement = document.querySelector(`#code-line-v1-${closestV1Line}`);
                console.log('Using fallback V1 line:', closestV1Line);
                if (fallbackElement) {
                    fallbackElement.classList.add('highlighted-line');
                    fallbackElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
    }
    
    // Highlight line in version 2 if it exists
    if (line2) {
        const v2LineElement = document.querySelector(`#code-line-v2-${line2}`);
        console.log('Looking for V2 line selector:', `#code-line-v2-${line2}`);
        console.log('V2 line element found:', !!v2LineElement);
        
        if (v2LineElement) {
            v2LineElement.classList.add('highlighted-line');
            v2LineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
            // Fallback: try to find the closest line number
            const closestV2Line = findClosestLine(line2, v2Lines);
            if (closestV2Line) {
                const fallbackElement = document.querySelector(`#code-line-v2-${closestV2Line}`);
                console.log('Using fallback V2 line:', closestV2Line);
                if (fallbackElement) {
                    fallbackElement.classList.add('highlighted-line');
                    fallbackElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
    }
}

function findClosestLine(targetLine, availableLines) {
    if (!availableLines || availableLines.length === 0) return null;
    
    const numericLines = availableLines.map(Number).filter(n => !isNaN(n));
    if (numericLines.length === 0) return null;
    
    // Find the closest line number
    let closest = numericLines[0];
    let minDistance = Math.abs(targetLine - closest);
    
    for (const line of numericLines) {
        const distance = Math.abs(targetLine - line);
        if (distance < minDistance) {
            minDistance = distance;
            closest = line;
        }
    }
    
    return closest.toString();
}

function getFirstLineNumber(codeData) {
    if (typeof codeData === 'object' && codeData.first_line_no) {
        return parseInt(codeData.first_line_no) || 1;
    }
    return 1;
}

function displayBothCodes() {
    // Display version 1 code
    if (trace1Data && trace1Data.function.code) {
        displayCodeContent(trace1Data.function.code, document.getElementById('code-container-v1'), 'v1');
    } else {
        document.getElementById('code-container-v1').textContent = 'No code available for Version 1';
    }
    
    // Display version 2 code  
    if (trace2Data && trace2Data.function.code) {
        displayCodeContent(trace2Data.function.code, document.getElementById('code-container-v2'), 'v2');
    } else {
        document.getElementById('code-container-v2').textContent = 'No code available for Version 2';
    }
}

function displayCodeContent(codeData, container, version) {
    let codeContent = '';
    let firstLineNo = 1;
    
    if (typeof codeData === 'object') {
        codeContent = codeData.content || codeData.code_content || '';
        firstLineNo = parseInt(codeData.first_line_no) || 1;
    } else {
        codeContent = codeData;
    }
    
    if (!codeContent) {
        container.textContent = 'No code content available';
        return;
    }
    
    // First, set the content for pre-highlighting
    container.textContent = codeContent;
    
    // Apply syntax highlighting
    if (typeof hljs !== 'undefined') {
        hljs.highlightElement(container);
    }
    
    // Get the highlighted HTML content
    const highlightedHtml = container.innerHTML;
    
    // Split the highlighted HTML by line breaks
    const highlightedLines = highlightedHtml.split('\n');
    
    // Add line numbers and make lines clickable while preserving highlighting
    const codeWithLineNumbers = highlightedLines.map((line, index) => {
        // Line number is offset by firstLineNo
        const lineNumber = index + firstLineNo;
        return `<div class="code-line" data-line="${lineNumber}" data-version="${version}" id="code-line-${version}-${lineNumber}">
                    <span class="line-number">${lineNumber.toString().padStart(4, ' ')}</span>
                    <span class="line-content">${line}</span>
                </div>`;
    }).join('\n');
    
    // Set the final HTML with line numbers and syntax highlighting
    container.innerHTML = codeWithLineNumbers;
    
    // Add click event to each line for cross-interaction with graph
    container.querySelectorAll('.code-line').forEach(line => {
        line.addEventListener('click', function() {
            const lineNumber = parseInt(this.dataset.line);
            const version = this.dataset.version;
            highlightCodeLineInBothVersions(lineNumber);
            highlightCorrespondingGraphNode(lineNumber, version);
        });
    });
}

function highlightCodeLine(lineNumber) {
    // Remove existing highlights
    document.querySelectorAll('.highlighted-line').forEach(el => {
        el.classList.remove('highlighted-line');
    });
    
    // Add highlight to specified line
    const lineElement = document.querySelector(`[data-line="${lineNumber}"]`);
    if (lineElement) {
        lineElement.classList.add('highlighted-line');
        lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

function highlightCorrespondingGraphNode(lineNumber, version) {
    // Find and highlight the corresponding graph node
    if (!simulation) return;
    
    const nodes = d3.select('#graph-svg').select('.graph-content').selectAll('circle');
    
    // First reset all nodes to normal appearance
    nodes
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .style('filter', 'none');
    
    // Then highlight nodes that match the line number
    nodes
        .filter(d => d.line1 === lineNumber || d.line2 === lineNumber)
        .attr('stroke', '#ffc107')
        .attr('stroke-width', 4)
        .style('filter', 'drop-shadow(0 0 8px rgba(255, 193, 7, 0.8))');
}

function highlightCodeLineInBothVersions(lineNumber) {
    // This function is now only used when clicking on code lines
    // Remove existing highlights
    document.querySelectorAll('.highlighted-line').forEach(el => {
        el.classList.remove('highlighted-line');
    });
    
    // Highlight the same line number in both code containers
    const v1LineElement = document.querySelector(`#code-line-v1-${lineNumber}`);
    const v2LineElement = document.querySelector(`#code-line-v2-${lineNumber}`);
    
    if (v1LineElement) {
        v1LineElement.classList.add('highlighted-line');
        v1LineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    if (v2LineElement) {
        v2LineElement.classList.add('highlighted-line');  
        v2LineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

function updateGraphStats(graphData) {
    const statsContent = document.getElementById('stats-content');
    
    const nodeCount = Object.keys(graphData.nodes).length;
    const edgeCount = graphData.edges.length;
    
    // Count by state
    const nodeCounts = { common: 0, modified: 0, only1: 0, only2: 0 };
    Object.values(graphData.nodes).forEach(node => {
        nodeCounts[node.state]++;
    });
    
    statsContent.innerHTML = `
        <div><strong>Nodes:</strong> ${nodeCount}</div>
        <div><strong>Edges:</strong> ${edgeCount}</div>
        <div style="margin-top: 5px;">
            <div style="color: ${stateColors.common};">■ Common: ${nodeCounts.common}</div>
            <div style="color: ${stateColors.modified};">■ Modified: ${nodeCounts.modified}</div>
            <div style="color: ${stateColors.only1};">■ Only V1: ${nodeCounts.only1}</div>
            <div style="color: ${stateColors.only2};">■ Only V2: ${nodeCounts.only2}</div>
        </div>
    `;
}

function updateEdgeLabels() {
    if (!graphSvg) return;
    
    const edgeLabels = graphSvg.select('.graph-content').selectAll('.edge-label-group');
    
    edgeLabels.select('text').text(d => {
        if (!selectedVariable) {
            return ''; // No variable selected, no labels
        }
        
        return getVariableChangeLabel(d, selectedVariable);
    });
    
    // Show/hide labels based on content
    edgeLabels.style('opacity', d => {
        if (!selectedVariable) return 0;
        const label = getVariableChangeLabel(d, selectedVariable);
        return label ? 1 : 0;
    });
}

function getVariableChangeLabel(edgeData, variable) {
    if (!variable) return '';
    
    console.log('Checking edge for variable changes:', variable, edgeData);
    
    let changes = [];
    
    // Check diff1 (changes in version 1)
    if (edgeData.diff1) {
        console.log('diff1 structure:', edgeData.diff1);
        
        if (Array.isArray(edgeData.diff1)) {
            edgeData.diff1.forEach(diffObj => {
                if (diffObj && typeof diffObj === 'object' && diffObj[variable]) {
                    const changeData = diffObj[variable];
                    console.log('Found V1 change for', variable, ':', changeData);
                    
                    if (Array.isArray(changeData) && changeData.length >= 2) {
                        const [oldVal, newVal] = changeData;
                        if (oldVal !== newVal) {
                            const oldStr = oldVal === null ? 'null' : String(oldVal).slice(0, 10);
                            const newStr = newVal === null ? 'null' : String(newVal).slice(0, 10);
                            changes.push(`V1: ${oldStr}→${newStr}`);
                        }
                    }
                }
            });
        } else if (typeof edgeData.diff1 === 'object' && edgeData.diff1[variable]) {
            // Handle case where diff1 is a direct object
            const changeData = edgeData.diff1[variable];
            console.log('Found V1 change (direct) for', variable, ':', changeData);
            
            if (Array.isArray(changeData) && changeData.length >= 2) {
                const [oldVal, newVal] = changeData;
                if (oldVal !== newVal) {
                    const oldStr = oldVal === null ? 'null' : String(oldVal).slice(0, 10);
                    const newStr = newVal === null ? 'null' : String(newVal).slice(0, 10);
                    changes.push(`V1: ${oldStr}→${newStr}`);
                }
            }
        }
    }
    
    // Check diff2 (changes in version 2)  
    if (edgeData.diff2) {
        console.log('diff2 structure:', edgeData.diff2);
        
        if (Array.isArray(edgeData.diff2)) {
            edgeData.diff2.forEach(diffObj => {
                if (diffObj && typeof diffObj === 'object' && diffObj[variable]) {
                    const changeData = diffObj[variable];
                    console.log('Found V2 change for', variable, ':', changeData);
                    
                    if (Array.isArray(changeData) && changeData.length >= 2) {
                        const [oldVal, newVal] = changeData;
                        if (oldVal !== newVal) {
                            const oldStr = oldVal === null ? 'null' : String(oldVal).slice(0, 10);
                            const newStr = newVal === null ? 'null' : String(newVal).slice(0, 10);
                            changes.push(`V2: ${oldStr}→${newStr}`);
                        }
                    }
                }
            });
        } else if (typeof edgeData.diff2 === 'object' && edgeData.diff2[variable]) {
            // Handle case where diff2 is a direct object
            const changeData = edgeData.diff2[variable];
            console.log('Found V2 change (direct) for', variable, ':', changeData);
            
            if (Array.isArray(changeData) && changeData.length >= 2) {
                const [oldVal, newVal] = changeData;
                if (oldVal !== newVal) {
                    const oldStr = oldVal === null ? 'null' : String(oldVal).slice(0, 10);
                    const newStr = newVal === null ? 'null' : String(newVal).slice(0, 10);
                    changes.push(`V2: ${oldStr}→${newStr}`);
                }
            }
        }
    }
    
    const result = changes.length > 0 ? changes.join('\n') : '';
    console.log('Variable change label result:', result);
    return result;
}

// Drag behavior functions
function dragStarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
}

function dragEnded(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    
    // Store user position
    userNodePositions[d.id] = { x: d.x, y: d.y };
    
    d.fx = null;
    d.fy = null;
}

// Utility functions
function resetGraphView() {
    if (graphSvg && currentTransform) {
        graphSvg.transition()
            .duration(500)
            .call(graphSvg.node().zoom?.transform || d3.zoom().transform, d3.zoomIdentity);
    }
}

function toggleControlsPanel() {
    const panel = document.getElementById('control-panel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

function centerGraph() {
    if (graphSvg) {
        const containerRect = document.getElementById('graph-container').getBoundingClientRect();
        const centerTransform = d3.zoomIdentity.translate(containerRect.width / 2, containerRect.height / 2);
        
        graphSvg.transition()
            .duration(500)
            .call(graphSvg.node().zoom?.transform || d3.zoom().transform, centerTransform);
    }
}

function showLoading(message) {
    console.log('showLoading called:', message);
    const loadingDiv = document.getElementById('loading-message');
    const svgElement = document.getElementById('graph-svg');
    
    loadingDiv.querySelector('p').textContent = message;
    loadingDiv.style.setProperty('display', 'flex', 'important');
    svgElement.style.display = 'none';
    
    console.log('Loading shown, SVG hidden');
}

function hideLoading() {
    console.log('hideLoading called');
    const loadingDiv = document.getElementById('loading-message');
    const svgElement = document.getElementById('graph-svg');
    
    loadingDiv.style.setProperty('display', 'none', 'important');
    svgElement.style.display = 'block';
    
    console.log('Loading hidden, SVG shown');
}

function showError(message) {
    const loadingDiv = document.getElementById('loading-message');
    loadingDiv.innerHTML = `
        <div class="text-center">
            <i class="bi bi-exclamation-triangle text-danger mb-3" style="font-size: 2rem;"></i>
            <p class="text-danger">${message}</p>
        </div>
    `;
    loadingDiv.style.display = 'flex';
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
</script>

<style>
.trace-comparison-container {
    height: 100vh;
    padding: 1rem;
}

/* Graph controls styling */
.control-header {
    border-bottom: 1px solid #dee2e6;
    margin-bottom: 8px;
    padding-bottom: 4px;
}

.form-check-sm .form-check-input {
    margin-top: 0.125rem;
}

.form-check-sm .form-check-label {
    font-size: 0.875rem;
}

/* Code styling similar to stack_recording.html */
.code-line {
    white-space: pre;
    line-height: 1.1;  /* Reduced from 1.3 to 1.1 for tighter spacing */
    display: flex;
    align-items: flex-start;
    padding: 0; /* Removed padding */
    cursor: pointer;
}

.code-line:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.line-number {
    min-width: 3em;
    text-align: right;
    padding-right: 0.5em;
    color: #6c757d;
    margin-right: 8px; /* Reduced from 10px */
    user-select: none;
    border-right: 1px solid #ddd;
    flex-shrink: 0;
    font-family: monospace;
    font-size: 12px; /* Slightly smaller */
}

.line-content {
    white-space: pre;
    flex-grow: 1;
    font-family: monospace;
    font-size: 12px; /* Slightly smaller */
}

.highlighted-line {
    background-color: #fff3cd !important;
    border-left: 4px solid #ffc107;
    padding-left: 4px;
}

.highlighted-line .line-number {
    color: #856404;
    font-weight: bold;
}

#graph-container {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
}

.form-select-sm, .btn-sm {
    font-size: 0.875rem;
}

/* Node states visualization */
.node-common { fill: #6c757d; }
.node-modified { fill: #fd7e14; }
.node-only1 { fill: #dc3545; }
.node-only2 { fill: #28a745; }

/* Edge label styles */
.edge-label-group {
    pointer-events: none;
}

.edge-label {
    font-family: monospace;
    font-size: 10px;
    fill: #333;
    text-anchor: middle;
    dominant-baseline: central;
}

.edge-label-background {
    fill: rgba(255, 255, 255, 0.95);
    stroke: #666;
    stroke-width: 0.5;
    rx: 3;
    filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.2));
}
</style>
{% endblock %} 